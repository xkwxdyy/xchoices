\NeedsTeXFormat{LaTeX2e}[2018/04/01]
\RequirePackage{expl3}
\ProvidesExplPackage {xchoices} {2022-01-28} {0.0.1}
  {
    A package for flexibly LaTeXing choice items based on hlist environment and coffin.
    Kangwei Xia
    <kangweixia_xdyy@163.com>
  }
\RequirePackage { l3keys2e, xparse }
\msg_new:nnn { xchoices } { l3-too-old }
  {
    Package~ "#1"~ is~ too~ old. \\\\
    Please~ update~ an~ up-to-date~ version~ of~ the~ bundles \\
    "l3kernel"~ and~ "l3packages"~ using~ your~ TeX~ package \\
    manager~ or~ from~ CTAN.
  }
\clist_map_inline:nn { expl3, xparse, l3keys2e }
  {
    \@ifpackagelater {#1} { 2018/05/12 }
      { } { \msg_error:nnn { xchoices } { l3-too-old } {#1} }
  }
%%%% 宏包载入 %%%%
\RequirePackage{ hlist }     % 对位宏包
\RequirePackage{ varwidth }
\RequirePackage{ tikz }      % 绘制带圈数字

% % hlist相关参数设置
% \sethlist
%   {
%     pre~label   = ,           % 使得label没有加粗效果
%     label~align = right,    % label的默认对齐方式是右对齐
%     item~sep    = 0.5em,
%   }

%%%% 变量声明 %%%%
\seq_new:N \l__xchoices_items_seq   % 用于储存最终分隔开的选项信息
\tl_new:N \l__xchoices_items_pre_check_tl   % 用于检测输入的结尾是否含有&&
\str_new:N \l__xchoices_items_pre_check_last_item_str  % 用于检测输入的最后一个是否是&
\dim_new:N \l__xchoices_max_width_dim   % 用于储存选项宽度的最大值
\int_new:N \l__xchoices_items_number_int  % 储存seq一共有多少项
\int_new:N \l__xchoices_env_xitem_int    % 用于xchoices环境的xitem计数
\int_zero:N \l__xchoices_env_xitem_int   % 先设初始值为0
\int_new:N \l__xchoices_items_per_line_int   % hlist环境每行排多少个

\dim_new:N \l__xchoices_linewidth_dim    % 储存当前行宽
\tl_new:N \l__xchoices_prelabel_tl    % label前面的内容
\tl_new:N \l__xchoices_hlist_label_style_tl   % label的样式
\tl_new:N \l__xchoices_postlabel_tl   % label后面的内容


%% quan 相关变量
\dim_new:N \l__quan_height_of_number_dim        % quan: 储存数字的高度
\dim_new:N \l__quan_radius_of_circle_dim        % quan: 圆的半径
\fp_new:N \l__quan_xscale_of_number_fp          % quan: 数字的水平压缩比例
\fp_new:N \l__quan_yscale_of_number_fp          % quan: 数字的垂直压缩比例

%%%% LaTeX2e命令复制 %%%%
% 复制\settoheight命令
\cs_set_eq:NN \my_settoheight:Nn \settoheight  % 获取高度

%%%% 产生变体函数 %%%%
\cs_generate_variant:Nn \dim_set:Nn { Nv, cv}
\cs_generate_variant:Nn \dim_max:nn { Vv }
\cs_generate_variant:Nn \seq_set_split:Nnn {NnV}
%%%% 键值设置 %%%%

% 错误键值的报错信息
\msg_new:nnn { xchoices } { unknown-option }
  { package~ option~ "\l_keys_key_tl"~ is~ unknown. }

% 将计数器的值转化为number（来源于hlist宏包源码）
\cs_new:Npn \__xchoices_arabic_counter:n #1
  {
    \number\csname c@\detokenize{#1} \endcsname
  }
% 注意键值里面用到函数的话，函数要在之前定义好
\cs_new:Npn \__xchoices_hlist_label_style_set:n #1
  {
    \str_if_eq:nnTF {#1} { quan }
      {
        \tl_set:Nn \l__xchoices_hlist_label_style_tl
          { \quan { \__xchoices_arabic_counter:n { hlisti } } }
        \tl_set:Nn \l__xchoices_postlabel_tl {~}
        \tl_set:Nn \l__xchoices_prelabel_tl {}
      }
      {
        \str_if_eq:nnTF {#1} { arabic }
          {
            \tl_set:Nn \l__xchoices_hlist_label_style_tl
              {
                \__xchoices_arabic_counter:n { hlisti }
              }
          }
          {
            \tl_set:Nn \l__xchoices_hlist_label_style_tl
              {
                \cs:w #1 \cs_end: { hlisti }
              }
          }
      }
  }
% hlistchoices的键值
\keys_define:nn { xchoices / hlistchoices }
  {
    % 每行排多少个（手动干预）
    items .int_set:N = \l__xchoices_items_per_line_int,
    % label前面的内容
    pre-label .tl_set:N = \l__xchoices_prelabel_tl,
    % label后面的内容
    post-label .tl_set:N = \l__xchoices_postlabel_tl,
    post-label .initial:n = {.},
    % label的样式
    label-style .code:n =
      { \__xchoices_hlist_label_style_set:n {#1} },
    label-style .initial:n = Alph,
    % 两行之间的额外间距
    vsep .dim_set:N = \l__xchocies_hlist_vsep_dim,
    vsep .initial:n = 0pt,
    % 两列之间的额外间距
    hsep .dim_set:N = \l__xchocies_hlist_hsep_dim,
    hsep .initial:n = 0pt,
    unknown .code:n = { \msg_error:nnn { xchoices } { unknown-option } {#1} }
  }

\NewDocumentCommand { \xchoices } { O{} +m }
  {
    \group_begin:
      \__xchoices_with_ampersand_output:n {#2}
      % 键值放在这是因为用户手动设置的per line的items数要覆盖前面自动计算的
      \keys_set:nn { xchoices / hlistchoices } {#1}
      % 用hlist环境排版
      \__xchoices_hlist_output:NNNNN
        \l__xchoices_items_seq
        \l__xchoices_items_per_line_int
        \l__xchoices_prelabel_tl
        \l__xchoices_hlist_label_style_tl
        \l__xchoices_postlabel_tl
    \group_end:
  }
\cs_new:Npn \__xchoices_hlist_output:NNNNN #1#2#3#4#5
  {
    \begin{hlist}[ label = #3 #4 #5 ]\int_use:N #2
      \seq_map_inline:Nn #1 
        { \hitem ##1 }
    \end{hlist}
  }
%% 用于接收带有&&的分隔内容
\cs_new:Npn \__xchoices_with_ampersand_output:n #1
  {
    % 先预处理接收的内容，看看末尾有没有&&，有的话就去掉
    \__xchoices_pre_check:n {#1}
    % 把处理后的内容储存到seq中
    \seq_set_split:NnV \l__xchoices_items_seq {&&} \l__xchoices_items_pre_check_tl
    % 然后对seq进行后续的判断处理
    \__xchoices_handle_seq_after_check:N
      \l__xchoices_items_seq
  }
%% 最终将seq传入的函数
\cs_new:Npn \__xchoices_handle_seq_after_check:N #1
  {
    % 将seq的项数进行储存，将seq的每一项都拿出来，储存到box中的varwidth环境里
    \__xchoices_store_items_and_width_of_seq_in_box:NN
      #1 \l__xchoices_items_number_int
    % 测量宽度，获取最大值
    \__xchoices_get_max_width:NNN
      \l__xchoices_max_width_dim
      \l__xchoices_measure_width_i_dim
      \l__xchoices_items_number_int
    % 根据最大值，确定hlist环境每行排版的个数
    \__xchoices_hlist_auto_items_calc:NNN
      \l__xchoices_items_per_line_int
      \l__xchoices_max_width_dim
      \l__xchoices_linewidth_dim
  }
%% 测量选项宽度的最大值
\cs_new:Npn \__xchoices_get_max_width:NNN #1#2#3
  % #1: 最大宽度储存变量
  % #2: 第一个选项的变量（先“初始化”max_dim）
  % #3: 选项的项数
  {
    % 先把第一个选项的值赋值给max_dim
    \dim_set_eq:NN #1 #2
    \int_step_inline:nn {#3}
      {
        \dim_set:Nn #1
          {
            \dim_max:Vv #1
              { l__xchoices_measure_width_ \int_to_roman:n { ##1 } _dim }
          }
      }
  }
%% 将最大宽度与行宽进行比较决定每行排多少个
\cs_new:Npn \__xchoices_hlist_auto_items_calc:NNN #1#2#3
  % #1: 每行的个数int变量
  % #2: 最大宽度
  % #3: 行宽
  {
    % 先储存行宽
    \dim_set_eq:NN #3 \linewidth
    % 比较最大宽度与行宽
    \dim_compare:nNnTF {#2} > { 0.4 #3 }
      { \int_set:Nn #1 {1} }
      {
        \dim_compare:nNnTF {#2} > { 0.2 #3 }
          { \int_set:Nn #1 {2} }
          { \int_set:Nn #1 {4} }
      }
  }

%% 储存seq的项到box变量，并将长度进行储存到dim变量
\cs_new:Npn \__xchoices_store_items_and_width_of_seq_in_box:NN #1#2
% #1: 要储存的seq变量
% #2: 项数储存的int变量
  {
    % 先储存seq的项数
    \int_set:Nn #2 { \seq_count:N #1 }
    % 循环遍历
    \int_step_inline:nn { #2 }
      {
        % box变量的声明，用来储存seq的每一项内容
        % 之所以要先判断是否存在，是因为new出来的变量是全局的
        % 如果只是new的话，第二次使用就会出现already define的报错，下面的dim的声明也是同理
        \box_if_exist:cF
          { l__xchoices_measure_width_ \int_to_roman:n { ##1 } _box }
          {
            % 不存在的话就新定义
            \box_new:c { l__xchoices_measure_width_ \int_to_roman:n { ##1 } _box }
          }
        % 声明dim变量
        \dim_if_exist:cF
          { l__xchoices_measure_width_ \int_to_roman:n { ##1 } _dim}
          {
            % 不存在的话就新定义
            \dim_new:c { l__xchoices_measure_width_ \int_to_roman:n { ##1 } _dim }
          }
        % 把每个选项存到对应的盒子里
        \hbox_set:cn { l__xchoices_measure_width_ \int_to_roman:n { ##1 } _box }
          {
            \begin{varwidth}{\hsize}
              \seq_item:Nn #1 { ##1 } 
            \end{varwidth}
          }
        % 把选项的长度进行储存
        \dim_set:cn { l__xchoices_measure_width_ \int_to_roman:n { ##1 } _dim }
          {
            \box_wd:c { l__xchoices_measure_width_ \int_to_roman:n { ##1 } _box }
          }
      }
  }


%% 预处理输入的信息，检测是否末尾有&&，有的话则去掉
\cs_new:Npn \__xchoices_pre_check:n #1
  {
    % 检测倒数第一个元素是不是&
    \__xchoices_pre_check_once:n {#1}
    % 检测倒数第二个元素是不是&
    \__xchoices_pre_check_once:V \l__xchoices_items_pre_check_tl
  }
% 辅助函数：只检测一个&
\cs_new:Npn \__xchoices_pre_check_once:n #1
  {
    % 先存起来
    \tl_set:Nn \l__xchoices_items_pre_check_tl {#1}
    % 把末尾元素拿出来
    \str_set:Nx \l__xchoices_items_pre_check_last_item_str
      {
        \tl_item:Nn \l__xchoices_items_pre_check_tl {-1}
      }
    % 检测是不是&
    \str_if_eq:VnT \l__xchoices_items_pre_check_last_item_str {&}
      {
        % 由于tl的remove是从第一个开始的，所以先把tl翻转
        \tl_reverse:N \l__xchoices_items_pre_check_tl
        % 去掉翻转后的（也就是原来的最后一个）第一个&
        \tl_remove_once:Nn \l__xchoices_items_pre_check_tl {&}
        % 再翻回来
        \tl_reverse:N \l__xchoices_items_pre_check_tl
      }
  }
\cs_generate_variant:Nn \__xchoices_pre_check_once:n {V}

\seq_new:N \l__xchoices_env_items_seq   % 用来存环境的seq
\cs_new:Nn \__xchoices_env_xitem_new:
  {
    % 如果是第一项的话就不需要\__xchoices_env_xitem_out:
    % 只有第二项开始才需要处理上一个
    \int_compare:nNnF { \l__xchoices_env_xitem_int } = { 0 }
      { \__xchoices_env_xitem_out: }
    % xitem计数器的值+1
    \int_incr:N \l__xchoices_env_xitem_int
    % 测试一下是否存在了对应值的box，不存在的话新声明一个
    \box_if_exist:cF { l__xchoices_env_ \int_to_roman:n { \l__xchoices_env_xitem_int } _box }
      {
        \box_new:c { l__xchoices_env_ \int_to_roman:n { \l__xchoices_env_xitem_int } _box }
      }
    \hbox_set:cw { l__xchoices_env_ \int_to_roman:n { \l__xchoices_env_xitem_int } _box }
      \begin{varwidth}{\hsize}
  }
\cs_new:Nn \__xchoices_env_xitem_out:
  {
      \end{varwidth}
    \hbox_set_end:
    % 把储存好内容的box传到seq里面
    \seq_put_right:Nx \l__xchoices_env_items_seq { \box_use:c { l__xchoices_env_ \int_to_roman:n { \l__xchoices_env_xitem_int } _box } }
  }


\NewDocumentEnvironment { xchoice } { O{} }
  {
    \group_begin:
      \int_zero:N \l__xchoices_env_xitem_int   % 先将xitem计数器设置为0
  }
  {
      \__xchoices_env_xitem_out:
      \__xchoices_handle_seq_after_check:N
        \l__xchoices_env_items_seq
      \keys_set:nn { xchoices / hlistchoices } {#1}
      \__xchoices_hlist_output:NNNNN
        \l__xchoices_env_items_seq
        \l__xchoices_items_per_line_int
        \l__xchoices_prelabel_tl
        \l__xchoices_hlist_label_style_tl
        \l__xchoices_postlabel_tl
    \group_end:
  }

\NewDocumentCommand { \xitem } {}
  {
    \__xchoices_env_xitem_new:
  }

% 带圈数字
\NewDocumentCommand{ \quan }{ m }
  {
    % 根据数字大小设置压缩系数
    \fp_set:Nn \l__quan_xscale_of_number_fp
      {
        \int_compare:nNnTF {#1} < { 10 } 
          { 0.9 }
          {
            \int_compare:nNnTF {#1} < { 100 }
              { 0.7 }
              { 0.5 }
          } 
      }
    \fp_set:Nn \l__quan_yscale_of_number_fp
      {
        \int_compare:nNnTF {#1} < { 10 } 
          { 0.9 }
          {
            \int_compare:nNnTF {#1} < { 100 }
              { 0.8 }
              { 0.6 }
          } 
      }
    % 获取数字的高度
    \my_settoheight:Nn \l__quan_height_of_number_dim {#1}
    % 设置圆的半径
    \dim_set:Nn \l__quan_radius_of_circle_dim 
      { \dim_eval:n { \l__quan_height_of_number_dim / 2 + 0.34 ex } }
    % 绘制
    \tikz[baseline]
      {
        \node at (0, \dim_use:N \l__quan_height_of_number_dim / 2 ) 
          {
            \makebox[0.35em][c]
              { 
                \scalebox { \fp_use:N \l__quan_xscale_of_number_fp } 
                [ \fp_use:N \l__quan_yscale_of_number_fp ] 
                  {
                    \int_compare:nNnTF {#1} > {99}
                      { \textbf {#1} }
                      {#1}
                  } 
              }
          };
        \draw (0, \dim_use:N \l__quan_height_of_number_dim / 2 )
          circle ( \l__quan_radius_of_circle_dim );
      }
  }

% hlist相关参数设置
\sethlist
  {
    pre~label   = ,           % 使得label没有加粗效果
    label~align = right,    % label的默认对齐方式是右对齐
    item~sep    =
      {
        \dim_eval:n { 0.5em + \l__xchocies_hlist_vsep_dim }
      },
    col~sep = 
      {
        \dim_eval:n { 2.5em + \l__xchocies_hlist_hsep_dim }
      },
  }